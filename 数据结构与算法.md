# 顺序表和链表

## 顺序表

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 结构定义
typedef struct vector {
    int size, count; // 顺序表大小和存入数据数量
    int *data; // 用指针索引内存，效果等同于数组
} vector;

// 顺序表初始化操作
vector *getNewVector(int n) {
    /**
     * malloc()函数返回的是一个void*类型的指针，即万能指针
     * 可以指向任何类型的数据，但本身没有明确的类型信息
     * 所以需要用(vector *)来告诉编译器，要在这块内存存放vector类型的对象
     */
    vector *p = (vector *)malloc(sizeof(vector)); // 为结构体分配内存
    p->size = n;
    p->count = 0;
    p->data = (int *)malloc(sizeof(int) * n);
    return p;
}

// 顺序表扩容
int expand(vector *v) {
    if (v == NULL) return 0; // 检测顺序表是否为空
    printf("expand v from %d to %d\n", v->size, 2 * v->size);
    /**realloc:对内存重新分配
     * if:内存足够向后扩展，则先扩展然后返回原地址
     * else if:找一个新的地址，将数据填充后返回新的地址
     * else:(内存占满)直接返回NULL
     * 若返回NULL，便会丢失数据，所以引用新指针接受地址
     * 若地址返回成功，再把地址传给data;
     */
    int *p = (int *)realloc(v->data, sizeof(int) * 2 * v->size);
    if (p == NULL) return 0;
    v->data = p;
    v->size *= 2;
    return 1;
}

// 顺序表插入
int insert(vector *v, int pos, int val) {
    if (pos < 0 || pos > v->count) return 0; //确保操作合法
    // 自动扩容顺序表
    if (v->size == v->count && !expand(v)) return 0;
    // 从后往前依次将数据向后移动一位，空出插入位置
    for (int i = v->count; i >= pos; i--){
        v->data[i + 1] = v->data[i];
    }
    v->data[pos] = val;
    v->count += 1;
    return 1;
}

// 顺序表删除
int erase(vector *v, int pos) {
    if (pos < 0 || pos > v->count) return 0;
    if (v->size == v->count)  return 0;
    for (int i = pos + 1; i < v->count; i++) {
        v->data[i - 1] = v->data[i];
    }
    v->count -= 1;
    return 1;
}

// 输出
void output_vecotr(vector *v) {
    printf("\n");
    int len = 0; 
    // printf会返回输出的字符串个数(\0除外)
    for (int i = 0; i < v->size; i++) {
        len += printf("%3d", i);
    }
    printf("\n");
    for (int i = 0; i < len; i++) printf("-");
    printf("\n");
    for (int i = 0; i < v->count; i++) {
        printf("%3d", v->data[i]);
    }
    printf("\n");
    return ;
}

// 顺序表销毁
void clear(vector *v) {
    if (v == NULL) return ;
    free(v->data); // 先释放数据列表的内存
    free(v); // 再释放结构体内存，防止数据泄露
    return;
}

int main() {
    srand(time(0));
    #define MAX_OP 20
    vector *v = getNewVector(2);
    for (int i = 0; i < MAX_OP; i++) {
        int op = rand() % 4, pos, val, ret;
        switch (op) {
            case 0:
            case 1:
            case 2:
                pos = rand() % (v->count + 2);
                val = rand() % 100;
                ret = insert(v, pos, val);
                printf("insert %d at %d to vector = %d\n",
                    val, pos, ret);
                break;
            case 3:
                pos = rand() % (v->count + 2);
                ret = erase(v, pos);
                printf("erase item at %d in vector = %d\n",
                    pos, ret);
                break;
        }
        output_vecotr(v);
    }
    clear(v);
    return 0;
}
```



## 链表

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define DL 3
#define STR(n) #n
#define DIGIT_LEN_STR(n) "%" STR(n) "d"

// 无头链表结构定义
typedef struct Node {
    int data;
    struct Node *next;
} Node;

// 链表初始化操作
Node *getNewNode(int val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = val;
    p->next = NULL;
    return p;
}

// 链表插入
/**
 * 哨兵节点作用：
 * - 避免处理头部插入（即pos=0）的特殊情况
 * 内存管理：
 * - 哨兵节点 new_head 是栈变量，函数返回后自动销毁，不影响链表。
 */
Node *insert(Node *head, int pos, int val) {
    // 创建一个临时哨兵节点（dummy head）和指针p
    Node new_head, *p = &new_head, *node = getNewNode(val);
    // 哨兵节点的next指向原链表头，构建临时链表
    new_head.next = head;
    // 移动指针p到插入位置的前一个节点
    for (int i = 0; i < pos; i++) p = p->next;
    // 插入新节点
    node->next = p->next;
    p->next = node;
    // 返回新链表的头结点(哨兵节点的next)
    return new_head.next;
}

// 链表销毁
void clear(Node *head) {
    if (head == NULL) return ;
    for (Node *p = head, *q; p; p = q) {
        q = p->next;
        free(p);
    }
    return ;
}

// 输出链表
void output_linklist(Node *head, int flag = 0) {
    int n = 0;
    for (Node *p = head; p; p = p->next) n += 1;
    for (int i = 0; i < n; i++) {
        printf(DIGIT_LEN_STR(DL), i);
        printf("  ");
    }
    printf("\n");
    for (Node *p = head; p; p = p->next) {
        printf(DIGIT_LEN_STR(DL), p->data);
        printf("->");
    }
    printf("\n");
    if (flag == 0) printf("\n\n");
    return ;
}

// 链表查找操作
int find(Node *head, int val) {
    Node *p = head;
    int n = 0;
    while (p) {
        if (p->data == val) {
            output_linklist(head, 1);
            int len = n * (DL + 2) + 2;
            for (int i = 0; i < len; i++) printf(" ");
            printf("^\n");
            for (int i = 0; i < len; i++) printf(" ");
            printf("|\n");
            return 1;
        }
        n += 1;
        p = p->next;
    }
    return 0;
}

int main() {
    srand(time(0));
    #define MAX_OP 7
    Node *head = NULL;
    for (int i = 0; i < MAX_OP; i++) {
        int pos = rand() % (i + 1), val = rand() % 100;
        printf("insert %d at %d to linklist\n", val, pos);
        head = insert(head, pos, val);
        output_linklist(head);
    }
    int val;
    while (~scanf("%d", &val)) {
        if (!find(head, val)) {
            printf("not found\n");
        }
    }
    clear(head);
    return 0;
}

```

# 排序

若存在一个顺序表或链表（以下用数组`vector`代替，思想一样），可以通过算法进行排序。

有以下常见方法：

| 算法     | 时间复杂度（平均） | 稳定性 | 是否原地排序 |
| -------- | ------------------ | ------ | ------------ |
| 冒泡排序 | O(n²)              | 稳定   | 是           |
| 选择排序 | O(n²)              | 不稳定 | 是           |
| 插入排序 | O(n²)              | 稳定   | 是           |
| 希尔排序 | O(n^1.3)           | 不稳定 | 是           |
| 归并排序 | O(n log n)         | 稳定   | 否           |
| 快速排序 | O(n log n)         | 不稳定 | 是           |
| 堆排序   | O(n log n)         | 不稳定 | 是           |
| 计数排序 | O(n + k)           | 稳定   | 否           |
| 桶排序   | O(n)               | 稳定   | 否           |
| 基数排序 | O(d(n + k))        | 稳定   | 否           |

这里只介绍**快速排序**和**归并排序**俩种方法

## 快速排序

若随机从数组中抽取一个数作为**基准值**ｐ，此时我们便可以把数组分为两部分：大于ｐ的和小于ｐ的。（或者是三部分：等于ｐ的）

此时再把数组拼接在一起，ｐ的位置就确定了。

然后我们只要把大于ｐ和小于ｐ的部分排好序，就行了。

我们可以构建一个（递归）函数ｆ，

函数实现的是：对放入数组进行排序

此函数存在边界：放入的数组只有一个数(左指针大于或等于右指针)

方法：将数组分为大于ｐ和小于ｐ的两部分，确定ｐ的位置，然后调用ｆ为大于ｐ和小于ｐ的部分排序

至此，函数便完成了。

其中，我们需要实现对数组（v）的分类，即：**小于ｐ的放在数组左边，大于ｐ的放在数组右边**

我们可以使用两个指针，一个指向左（l）一个指向右（r）。我们可以取中间为基准值：`m =（left + right）/ 2，p = v[m]`。

然后两边向中间缩进，直到找到左边第一个大于p的和右边第一个小于p的，然后将两数交换位置。然后一直循环此操作，直到`r < l`。

此时p的位置确定，然后调用函数f为剩下两部分排序。

```c++
// 示例代码
void f(vector<int>& v,int left, int right) {
    if (left >= right) return;	// 边界：数组只有一个数(left>right)防溢出
    int m = (left+right)/2, l = left, r = right, p = v[m]; // 依次为：基准值下标，左指针，右指针和基准值（使用p防止v[m]位置改变）
    while (l<=r) {
        while (v[l] < p) l++;	// 找 >= p 的
        while (v[r] > p) r--;	// 找 <= p 的
        if (l<=r) {
            int q = v[l];
            v[l] = v[r];
            v[r] = q;
            l++;
            r--;
        }
    }
    // 此时[left, r] <= p, [l, right] >= p
    f(v, left, r); // 递归处理左半部分
    f(v, l, right); // 递归处理右半部分
}
```

***

如果遇到包含大量重复元素的数组，我们可以用**三路快排**

我们使用**一个指针扫描+两个边界指针**维护三个区域。

我们创建左指针（l），右指针（r）和扫描指针（i）

让i从l到r遍历，遇到小于p的与l交换（`swap(v[i], v[l])`，同理遇到大于p的与r交换，并且在交换后同步指针（l++，r--）

结束后，数组便分为三个部分

```c++
// 示例代码

void quicksort3way(vector<int>& v, int left, int right) {
    if (left >= right) return;

    int pivot = v[left];  // 可优化为随机或三数取中
    int l = left;        // [left, l-1] < pivot
    int r = right;       // [r+1, right] > pivot
    int i = left + 1;     // 当前扫描位置

    while (i <= r) {
        if (v[i] < pivot) {
            swap(v[i], v[l]);
            l++;
            i++;
        } else if (v[i] > pivot) {
            swap(v[i], v[r]);
            r--;
            // i 不增加，因为r换过来的元素还没检查
        } else {
            i++;
        }
    }

    // 此时：
    // [left, l-1] < pivot
    // [l, r] == pivot
    // [r+1, right] > pivot

    quicksort3way(v, left, l - 1);
    quicksort3way(v, r + 1, right);
}
```

## 归并排序

我们可以把无序数组从中间分成两部分，把两部分分别排序完成之后，就是标准的合并两个有序数组:[力扣88题](https://leetcode.cn/problems/merge-sorted-array/description/)。

关于合并有序数组，我们可以对数组遍历，比较数组右边数据的大小。将符合条件的数据（如果是升序则是更小的数，反之是更大的数）依次移动到临时数组。我们可以设置三个指针：i,j,k分别对应原有序数组`arr1`和`arr2`以及收集合并后的数据的临时数组`add` 。以升序为例，我们比较`arr1[i]`和`arr2[j]`若`arr1[i]>arr2[j]`则`add[k]=arr2[j]`然后j和k递增（可以简写为`add[k++] = arr2[j++]`）反之是i和k。我们以`i <= arr1.size() && j <= arr2.size()`为临界，对刚才的操作循环。此时会出现一个数组遍历完成，另一个数组还有剩余的情况，我们直接按顺序将数据插入add队尾即可。

```c++
// 合并有序数组
vector<int> addlist(vector<int>& arr1, vector<int>& arr2){
    int a1 = arr1.size(), a2 = arr2.size();
    vector<int> add(a1 + a2); // 临时数组
    int i = 0, j = 0, k = 0; // 指针
    // 合并数组
    while(i < a1 && j < a2){
        if(arr1[i] <= arr2[j])	add[k++] = arr1[i++];
        else add[k++] = arr2[j++];
    }
    // 处理剩余数据
    while(i < a1)	add[k++] = arr1[i++];
    while(j < a2) 	add[k++] = arr2[j++];
    return add;
}
```

利用递归，把数组差分为每个数组只有一个数据。因为一个数据可以理解为有序，便可以使用“合并有序数组”依次合并。

```c++
// 归并排序
void mergeSort(vector<int>& arr, int left, int right) {
    // 边界
    if (left >= right) return;

    // 拆分
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    // 合并
    int len = right - left + 1;
    vector<int> temp(len);
    int i = left, j = mid + 1, k = 0;
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) temp[k++] = arr[i++];
        else temp[k++] = arr[j++];
    }
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    for (int i = 0; i < len; i++) arr[left + i] = temp[i];
}

void mergeSort(vector<int>& arr) {
    if (!arr.empty())   mergeSort(arr, 0, arr.size() - 1);
}
```

思路：

1. 把数组分为两部分
2. 调用自身，把两部分排好序
3. 合并有序数组


